# BugFinder-Framework
This is a framework dedicated to automating finding bugs in source artefacts based on measurements 
and machine learning algorithms.

This framework´s main use case is researching correlations between measurements and bug occurrence.
It addresses reusability, modifiability and portability (adaptability, installibility and replaceability) 
of components needed to research correlations between source artefact measurements and bug occurrence. 

Different researchers should be able to exchange components of the bugfinder program and therefore
be able to distribute research among researchers world wide. With all needed components given
you should be able to automatically analyse code and find localities with high bug probability.

# Table of Contents  
- [BugFinder-Framework](#bugfinder-framework)
- [Table of Contents](#table-of-contents)
- [Quick start](#quick-start)
- [Introduction](#introduction)
  * [Recording by example](#recording-by-example)
  * [Preprocessing by example](#preprocessing-by-example)
  * [Training](#training)
- [Component realisations available](#component-realisations-available)
  * [Shared](#shared)
    + [DB](#db)
  * [Recording](#recording)
    + [LocalityRecorder (and therefore localities)](#localityrecorder--and-therefore-localities-)
    + [LocalityPreprocessors](#localitypreprocessors)
    + [Quantifier](#quantifier)
    + [Annotator](#annotator)
  * [Preprocessor](#preprocessor)
  * [Machine Learning](#machine-learning)
<!--<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>-->

# Quick start
The best way to start is to clone the [bugFinder repository](https://github.com/penguinsAreFunny/bugFinder) and make changes there.  
You can change components for locality-recording, locality-preprocessing, quantification, annotation and preprocessing.


<a name="introduction"></a>
# Introduction
The whole process beginning with recording until classification of localities is designed with a
pipeline:
![Machine_Learning_Pipeline](./doc/Pipeline.svg)  

This project supports the learning phase. This framework defines all interfaces for each step of the pipeline.
Researchers want to develop or use others´ implementation of the components needed to realise
this machine learning pipeline. Please see the main repository: [bugFinder repository](https://github.com/penguinsAreFunny/bugFinder) for whole documentation.

## Recording by example 
All used examples in the following documentations are already implemented and ready to use. 

Record all features. F.e. record all Lines Of Code for each file in each Commit.

1. You first need to record all localities, CommitPaths, of a repository. 
A CommitPath is a path in a commit.

2. After that you can preprocess your CommitPaths. For example filtering all the paths you do not
want to quantify, like .txt-, .md-files and only keep CommitPaths with paths in src ending with .ts.

3. After that you want to quantify your CommitPaths, f.e. with the SonarQubeQuantifier. Therefore getting 
a map of CommitPaths to SonarQubeMeasurements.

4. You might also want to annotate your localities so that you have labels needed 
for suppervised learning algorithms. You can label your CommitPaths with analyzing the Commit-message
for semantic key words like "bug, fix, error, fail" indicating a correction of a bug.

Now you have a database of localities, quantifications (features) and annotations (classes).

## Preprocessing by example 
Preprocess your data from the recording phase.

F.e.: Find the last 3 changes of a CommitPath with a bug indicating commit message. Those changes
are localities by them self: CommitPaths. Now you can analyse the changes made before a CommitPath
got a bug. F.e. the max. added Lines Of Code in a change. 

In the training phase you might find statistical correlation between the amount of lines of codes 
added in one single change and the likelyhood of a bug beeing fixed later in that file. Therefore
indicating a bug added in that file.

## Training 
Training is give by a template project: @see [bugFinder-machineLearning](https://github.com/penguinsAreFunny/bugFinder-machineLearning)  
You want to train a model to be able to predict bugs using the dataset generated by the previous steps.

# Component realisations available
You can find different components realisations open source on github and npm.
Search for bugfinder-*
## Shared
### DB
- [Commit-MongoDB](https://www.npmjs.com/package/bugfinder-commit-db-mongodb)
- [CommitPath-MongoDB](https://www.npmjs.com/package/bugfinder-commitpath-db-mongodb)
## Recording
### LocalityRecorder (and therefore localities)
npm search: bugfinder-localityrecorder-*
- [CommitPath](https://www.npmjs.com/package/bugfinder-localityrecorder-commitpath)
- [Commit](https://www.npmjs.com/package/bugfinder-localityrecorder-commit)

### LocalityPreprocessors
npm search: bugfinder-$LOCALITY_CLASS-localityPreprocessor-* 
- [Predecessors](https://www.npmjs.com/package/bugfinder-commitpath-localitypreprocessor-commitsubset)
### Quantifier
npm search: bugfinder-$LOCALITY_CLASS-quantifier-*
- [SonarQube](https://github.com/penguinsAreFunny/bugFinder-commitPath-quantifier-sonarqube)
- [SonarQubePredecessors](https://github.com/penguinsAreFunny/bugFinder-commitPath-quantifier-sonarqubePredecessors)
### Annotator
npm search: bugfinder-$LOCALITY_CLASS-annotator-*
- [CommitMsg](https://www.npmjs.com/package/bugfinder-commitpath-annotator-commitmsg)
- [CommitMsgPredecessors](https://github.com/penguinsAreFunny/bugFinder-commitPath-annotator-commitMsgPredecessors)
## Preprocessor
npm search: bugfinder-$LOCALITY_CLASS-$ANNOTATION_TYPE-$QUANTIFICATION_TYPE-preprocessor-*
- [featureSelection](https://github.com/penguinsAreFunny/bugFinder-commitpath-number-sonarqube-preprocessor-featureSelection)
## Machine Learning
- [bugFinder-machineLearning](https://github.com/penguinsAreFunny/bugFinder-machineLearning)  
